/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ContentLinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ContentLinkerPlugin = class extends import_obsidian.Plugin {
  /**
   * Plugin onload event handler.
   */
  async onload() {
    await this.loadSettings();
    console.log("Loading Content Linker plugin");
    this.addCommand({
      id: "search-possible-bi-directional-links",
      name: "Search possible bi-directional links in vault",
      callback: async () => {
        await this.searchPossibleBiLinks();
        await this.saveSettings();
      }
    });
    this.addSettingTab(new ContentLinkerSettingTab(this.app, this));
  }
  /**
   * Load plugin data from storage.
   */
  async loadSettings() {
    this.settings = Object.assign(
      {},
      {
        biLinks: [],
        optionsCount: 10,
        ignoredContent: [],
        relativePathOfExcludedNotes: ""
      },
      await this.loadData()
    );
  }
  /**
   * Save plugin data to storage.
   */
  async saveSettings() {
    this.saveData(this.settings);
  }
  /**
   * Search for possible bi-links in the vault.
   */
  async searchPossibleBiLinks() {
    const vault = this.app.vault;
    const notes = this.settings.relativePathOfExcludedNotes === "" ? vault.getMarkdownFiles() : vault.getMarkdownFiles().filter((file) => !file.path.includes(this.settings.relativePathOfExcludedNotes.toString()));
    const existingBiLinks = /* @__PURE__ */ new Set();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const biLinkKeywords = content.match(/\[\[(.+?)\]\]/g) || [];
      for (const biLink of biLinkKeywords) {
        const keyword = biLink.slice(2, -2);
        existingBiLinks.add(keyword);
      }
    }
    const potentialBiLinks = /* @__PURE__ */ new Map();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const uniqueKeywords = content.match(/\b\w+\b/g) || [];
      for (const keyword of uniqueKeywords) {
        if (!potentialBiLinks.has(keyword) && !this.settings.biLinks.some((biLink) => biLink.keyword === keyword) && !existingBiLinks.has(keyword) && !content.includes(`[[${keyword}]]`) && !this.settings.ignoredContent.some(
          (ignoredContent) => ignoredContent.keyword === keyword
        )) {
          potentialBiLinks.set(keyword, 1);
        } else {
          potentialBiLinks.set(
            keyword,
            (potentialBiLinks.get(keyword) || 0) + 1
          );
        }
      }
    }
    this.settings.biLinks = Array.from(potentialBiLinks.entries()).map(
      ([keyword, count]) => ({
        keyword,
        count,
        isSelected: false
      })
    );
    await this.saveSettings();
    new import_obsidian.Notice("Search finished!");
  }
};
var ContentLinkerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const relativePathExclusion = new import_obsidian.Setting(containerEl).setName("Relative path of excluded notes").setDesc("Enter a relative path:");
    relativePathExclusion.addText((input) => input.setPlaceholder("Relative path of exluded notes").setValue(this.plugin.settings.relativePathOfExcludedNotes.toString()).onChange(async (value) => {
      this.plugin.settings.relativePathOfExcludedNotes = value;
      await this.plugin.saveSettings();
    }));
    const searchButton = containerEl.createEl("button", {
      text: "Search possible bi-directional links in vault"
    });
    searchButton.addEventListener("click", async () => {
      await this.plugin.searchPossibleBiLinks();
      this.display();
    });
    new import_obsidian.Setting(containerEl).setName("Possible bi-directional content").setDesc("Enter a number:").addText(
      (text) => text.setValue(this.plugin.settings.optionsCount.toString()).onChange(async (value) => {
        const parsedValue = parseFloat(value);
        if (!isNaN(parsedValue)) {
          this.plugin.settings.optionsCount = parsedValue;
        }
      })
    );
    const countButton = containerEl.createEl("button", {
      text: "Update number of search results"
    });
    countButton.addEventListener("click", async () => {
      await this.plugin.searchPossibleBiLinks();
      this.display();
    });
    const table = containerEl.createEl("table", { cls: "content-linker-table" });
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    headerRow.insertCell().textContent = "No.";
    headerRow.insertCell().textContent = "Count";
    headerRow.insertCell().textContent = "Keyword";
    headerRow.insertCell().textContent = "Selected";
    const sortedBiLinks = this.plugin.settings.biLinks.sort((a, b) => b.count - a.count).slice(0, this.plugin.settings.optionsCount);
    const tbody = table.createTBody();
    for (let index = 0; index < sortedBiLinks.length; index++) {
      const { keyword, count, isSelected } = sortedBiLinks[index];
      const isAlreadyBiLink = await this.isAlreadyBiLink(keyword);
      if (!isAlreadyBiLink && !this.isIgnored(keyword)) {
        const row = tbody.insertRow();
        row.insertCell().textContent = (index + 1).toString();
        row.insertCell().textContent = count.toString();
        row.insertCell().textContent = keyword;
        row.insertCell().appendChild(this.createCheckbox(keyword, isSelected));
      }
    }
    const updateButton = containerEl.createEl("button", {
      text: "Update bi-directional link for selected option(s)"
    });
    updateButton.addEventListener("click", async () => {
      await this.updateBiLinks();
      await this.plugin.searchPossibleBiLinks();
      this.display();
    });
    const ignoreButton = containerEl.createEl("button", {
      text: "Ignore selected option(s)"
    });
    ignoreButton.addEventListener("click", async () => {
      await this.ignoreSelectedOptions();
    });
    this.displayIgnoredContentList();
  }
  /**
   * Check if a keyword is ignored.
   * @param keyword - The keyword to check.
   * @returns True if ignored, false otherwise.
   */
  isIgnored(keyword) {
    return this.plugin.settings.ignoredContent.some(
      (ignoredContent) => ignoredContent.keyword === keyword
    );
  }
  /**
   * Check if a keyword is already a bi-link in any note.
   * @param keyword - The keyword to check.
   * @returns True if it is already a bi-link, false otherwise.
   */
  async isAlreadyBiLink(keyword) {
    const vault = this.plugin.app.vault;
    const notes = vault.getMarkdownFiles();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const regex = new RegExp(`\\[\\[${keyword}\\]\\]`, "g");
      if (content.match(regex)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Create a checkbox element for a bi-link option.
   * @param keyword - The keyword for the bi-link.
   * @param checked - Whether the checkbox is selected.
   * @returns The created checkbox element.
   */
  createCheckbox(keyword, checked) {
    const checkboxContainer = document.createElement("label");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = checked;
    checkboxContainer.appendChild(checkbox);
    checkbox.addEventListener("change", async () => {
      this.plugin.settings.biLinks = this.plugin.settings.biLinks.map(
        (biLink) => biLink.keyword === keyword ? { ...biLink, isSelected: checkbox.checked } : biLink
      );
      await this.plugin.saveSettings();
    });
    return checkboxContainer;
  }
  async updateBiLinks() {
    const selectedBiLinks = this.plugin.settings.biLinks.filter(
      (biLink) => biLink.isSelected
    );
    this.plugin.settings.biLinks = this.plugin.settings.biLinks.map(
      (biLink) => selectedBiLinks.some(({ keyword }) => biLink.keyword === keyword) ? { ...biLink, isSelected: false } : biLink
    );
    const vault = this.plugin.app.vault;
    const notes = vault.getMarkdownFiles();
    const totalNotes = notes.length;
    let indexCount = 0;
    for (const selectedBiLink of selectedBiLinks) {
      const { keyword } = selectedBiLink;
      for (const note of notes) {
        if (!this.isExcluded(note.path)) {
          let content = await vault.read(note);
          const regex = new RegExp(
            `\\b${keyword.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\b`,
            "g"
          );
          content = content.replace(regex, `[[${keyword}]]`);
          await vault.modify(note, content);
        }
        indexCount++;
        this.showProgress(indexCount, totalNotes);
      }
    }
    await this.plugin.saveSettings();
    new import_obsidian.Notice("Update finished!");
  }
  /**
   * Check if a note path is excluded.
   * @param path - The path of the note.
   * @returns True if the note path is excluded, false otherwise.
   */
  isExcluded(path) {
    if (this.plugin.settings.relativePathOfExcludedNotes === "")
      return false;
    return path.includes(this.plugin.settings.relativePathOfExcludedNotes.toString());
  }
  /**
   * Ignore the selected bi-link options.
   */
  async ignoreSelectedOptions() {
    const selectedOptions = this.plugin.settings.biLinks.filter(
      (biLink) => biLink.isSelected
    );
    for (const selectedOption of selectedOptions) {
      const { keyword } = selectedOption;
      selectedOption.isSelected = false;
      if (!this.plugin.settings.ignoredContent.some(
        (ignoredContent) => ignoredContent.keyword === keyword
      )) {
        this.plugin.settings.ignoredContent.push(selectedOption);
      }
    }
    this.plugin.settings.biLinks = this.plugin.settings.biLinks.filter(
      (biLink) => !biLink.isSelected
    );
    await this.plugin.saveSettings();
    await this.plugin.searchPossibleBiLinks();
    this.display();
  }
  /**
   * Display the ignored content list.
   */
  async displayIgnoredContentList() {
    const { containerEl } = this;
    const ignoredContentSetting = new import_obsidian.Setting(containerEl).setName("Ignored content list").setDesc("Keywords that you want to ignore");
    const ignoredContentTable = containerEl.createEl("table", {
      cls: "content-linker-ignored-content-table"
    });
    const ignoredContentThead = ignoredContentTable.createTHead();
    const ignoredContentHeaderRow = ignoredContentThead.insertRow();
    ignoredContentHeaderRow.insertCell().textContent = "No.";
    ignoredContentHeaderRow.insertCell().textContent = "Count";
    ignoredContentHeaderRow.insertCell().textContent = "Keyword";
    ignoredContentHeaderRow.insertCell().textContent = "Selected";
    const sortedIgnoredList = this.plugin.settings.ignoredContent.sort(
      (a, b) => b.count - a.count
    );
    const ignoredContentTbody = ignoredContentTable.createTBody();
    for (let i = 0; i < sortedIgnoredList.length; i++) {
      const { keyword, count, isSelected } = sortedIgnoredList[i];
      const row = ignoredContentTbody.insertRow();
      row.insertCell(0).textContent = (i + 1).toString();
      row.insertCell(1).textContent = count ? count.toString() : "";
      row.insertCell(2).textContent = keyword;
      row.insertCell(3).appendChild(
        this.createIgnoredCheckbox(keyword, isSelected)
      );
    }
    containerEl.appendChild(ignoredContentTable);
    const removeButton = containerEl.createEl("button", {
      text: "Remove selected option(s) from ignored content list"
    });
    removeButton.addEventListener("click", async () => {
      this.removeFromIgnoredList();
    });
  }
  /**
   * Create a checkbox element for an ignored option.
   * @param keyword - The keyword for the ignored option.
   * @param checked - Whether the checkbox is selected.
   * @returns The created checkbox element.
   */
  createIgnoredCheckbox(keyword, checked) {
    const checkboxContainer = document.createElement("label");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = checked;
    checkboxContainer.appendChild(checkbox);
    checkbox.addEventListener("change", async () => {
      this.plugin.settings.ignoredContent = this.plugin.settings.ignoredContent.map(
        (ignoredContent) => ignoredContent.keyword === keyword ? { ...ignoredContent, isSelected: checkbox.checked } : ignoredContent
      );
      await this.plugin.saveSettings();
    });
    return checkboxContainer;
  }
  /**
   * Remove the selected options from the ignored content list.
   */
  async removeFromIgnoredList() {
    const selectedIgnoredOptions = this.plugin.settings.ignoredContent.filter(
      (ignoredContent) => {
        return ignoredContent.isSelected;
      }
    );
    for (const selectedIgnoredOption of selectedIgnoredOptions) {
      const { keyword } = selectedIgnoredOption;
      const index = this.plugin.settings.ignoredContent.findIndex(
        (ignoredContent) => ignoredContent.keyword === keyword
      );
      if (index !== -1) {
        this.plugin.settings.ignoredContent.splice(index, 1);
      }
    }
    await this.plugin.saveSettings();
    this.display();
  }
  async showProgress(indexCount, totalNumber) {
    if (indexCount == 1 || indexCount % 100 == 0 || indexCount == totalNumber) {
      const message = `Updating: ${indexCount} of ${totalNumber}`;
      new import_obsidian.Notice(message);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmludGVyZmFjZSBCaUxpbmsge1xyXG4gIGtleXdvcmQ6IHN0cmluZztcclxuICBjb3VudDogbnVtYmVyO1xyXG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBJZ25vcmVkQ29udGVudCB7XHJcbiAga2V5d29yZDogc3RyaW5nO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgaXNTZWxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvbnRlbnRMaW5rZXJQbHVnaW5TZXR0aW5ncyB7XHJcbiAgYmlMaW5rczogQmlMaW5rW107XHJcbiAgb3B0aW9uc0NvdW50OiBudW1iZXI7XHJcbiAgaWdub3JlZENvbnRlbnQ6IElnbm9yZWRDb250ZW50W107XHJcbiAgcmVsYXRpdmVQYXRoT2ZFeGNsdWRlZE5vdGVzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRMaW5rZXJQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cclxuICBzZXR0aW5nczogQ29udGVudExpbmtlclBsdWdpblNldHRpbmdzO1xyXG5cclxuICAvKipcclxuICAgKiBQbHVnaW4gb25sb2FkIGV2ZW50IGhhbmRsZXIuXHJcbiAgICovXHJcbiAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnTG9hZGluZyBDb250ZW50IExpbmtlciBwbHVnaW4nKTtcclxuXHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogJ3NlYXJjaC1wb3NzaWJsZS1iaS1kaXJlY3Rpb25hbC1saW5rcycsXHJcbiAgICAgIG5hbWU6ICdTZWFyY2ggcG9zc2libGUgYmktZGlyZWN0aW9uYWwgbGlua3MgaW4gdmF1bHQnLFxyXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTsgLy8gU2F2ZSBkYXRhIGFmdGVyIG1ha2luZyBjaGFuZ2VzXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IENvbnRlbnRMaW5rZXJTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIHBsdWdpbiBkYXRhIGZyb20gc3RvcmFnZS5cclxuICAgKi9cclxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAge30sXHJcbiAgICAgIHtcclxuICAgICAgICBiaUxpbmtzOiBbXSxcclxuICAgICAgICBvcHRpb25zQ291bnQ6IDEwLFxyXG4gICAgICAgIGlnbm9yZWRDb250ZW50OiBbXSxcclxuICAgICAgICByZWxhdGl2ZVBhdGhPZkV4Y2x1ZGVkTm90ZXM6ICcnLFxyXG4gICAgICB9LFxyXG4gICAgICBhd2FpdCB0aGlzLmxvYWREYXRhKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIHBsdWdpbiBkYXRhIHRvIHN0b3JhZ2UuXHJcbiAgICovXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaCBmb3IgcG9zc2libGUgYmktbGlua3MgaW4gdGhlIHZhdWx0LlxyXG4gICAqL1xyXG4gIGFzeW5jIHNlYXJjaFBvc3NpYmxlQmlMaW5rcygpIHtcclxuICAgIGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcblxyXG4gICAgY29uc3Qgbm90ZXMgPSB0aGlzLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3RlcyA9PT0gJycgPyB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkgOiB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gIWZpbGUucGF0aC5pbmNsdWRlcyh0aGlzLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3Rlcy50b1N0cmluZygpKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGV4aXN0aW5nQmlMaW5rcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChub3RlKTtcclxuXHJcbiAgICAgIGNvbnN0IGJpTGlua0tleXdvcmRzID0gY29udGVudC5tYXRjaCgvXFxbXFxbKC4rPylcXF1cXF0vZykgfHwgW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGJpTGluayBvZiBiaUxpbmtLZXl3b3Jkcykge1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSBiaUxpbmsuc2xpY2UoMiwgLTIpO1xyXG4gICAgICAgIGV4aXN0aW5nQmlMaW5rcy5hZGQoa2V5d29yZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwb3RlbnRpYWxCaUxpbmtzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXMpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQobm90ZSk7XHJcblxyXG4gICAgICBjb25zdCB1bmlxdWVLZXl3b3JkcyA9IGNvbnRlbnQubWF0Y2goL1xcYlxcdytcXGIvZykgfHwgW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2YgdW5pcXVlS2V5d29yZHMpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhcG90ZW50aWFsQmlMaW5rcy5oYXMoa2V5d29yZCkgJiZcclxuICAgICAgICAgICF0aGlzLnNldHRpbmdzLmJpTGlua3Muc29tZSgoYmlMaW5rKSA9PiBiaUxpbmsua2V5d29yZCA9PT0ga2V5d29yZCkgJiZcclxuICAgICAgICAgICFleGlzdGluZ0JpTGlua3MuaGFzKGtleXdvcmQpICYmXHJcbiAgICAgICAgICAhY29udGVudC5pbmNsdWRlcyhgW1ske2tleXdvcmR9XV1gKSAmJlxyXG4gICAgICAgICAgIXRoaXMuc2V0dGluZ3MuaWdub3JlZENvbnRlbnQuc29tZShcclxuICAgICAgICAgICAgKGlnbm9yZWRDb250ZW50KSA9PiBpZ25vcmVkQ29udGVudC5rZXl3b3JkID09PSBrZXl3b3JkXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBwb3RlbnRpYWxCaUxpbmtzLnNldChrZXl3b3JkLCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG90ZW50aWFsQmlMaW5rcy5zZXQoXHJcbiAgICAgICAgICAgIGtleXdvcmQsXHJcbiAgICAgICAgICAgIChwb3RlbnRpYWxCaUxpbmtzLmdldChrZXl3b3JkKSB8fCAwKSArIDFcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXR0aW5ncy5iaUxpbmtzID0gQXJyYXkuZnJvbShwb3RlbnRpYWxCaUxpbmtzLmVudHJpZXMoKSkubWFwKFxyXG4gICAgICAoW2tleXdvcmQsIGNvdW50XSkgPT4gKHtcclxuICAgICAgICBrZXl3b3JkLFxyXG4gICAgICAgIGNvdW50LFxyXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuICAgIG5ldyBOb3RpY2UoJ1NlYXJjaCBmaW5pc2hlZCEnKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENvbnRlbnRMaW5rZXJTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBDb250ZW50TGlua2VyUGx1Z2luO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBDb250ZW50TGlua2VyUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRpc3BsYXkoKSB7XHJcblxyXG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgIC8vIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0V4Y2x1ZGUgbm90ZXMgd2l0aCByZWxhdGl2ZSBwYXRoJyB9KTtcclxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aEV4Y2x1c2lvbiA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnUmVsYXRpdmUgcGF0aCBvZiBleGNsdWRlZCBub3RlcycpXHJcbiAgICAgIC5zZXREZXNjKCdFbnRlciBhIHJlbGF0aXZlIHBhdGg6JylcclxuICAgIHJlbGF0aXZlUGF0aEV4Y2x1c2lvbi5hZGRUZXh0KGlucHV0ID0+IGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignUmVsYXRpdmUgcGF0aCBvZiBleGx1ZGVkIG5vdGVzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3Rlcy50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXRpdmVQYXRoT2ZFeGNsdWRlZE5vdGVzID0gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcblxyXG4gICAgY29uc3Qgc2VhcmNoQnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuICAgICAgdGV4dDogJ1NlYXJjaCBwb3NzaWJsZSBiaS1kaXJlY3Rpb25hbCBsaW5rcyBpbiB2YXVsdCcsXHJcbiAgICB9KTtcclxuICAgIHNlYXJjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgIHRoaXMuZGlzcGxheSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKCdQb3NzaWJsZSBiaS1kaXJlY3Rpb25hbCBjb250ZW50JylcclxuICAgICAgLnNldERlc2MoJ0VudGVyIGEgbnVtYmVyOicpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQudG9TdHJpbmcoKSlcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQgPSBwYXJzZWRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICBjb25zdCBjb3VudEJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6ICdVcGRhdGUgbnVtYmVyIG9mIHNlYXJjaCByZXN1bHRzJyxcclxuICAgIH0pO1xyXG4gICAgY291bnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNlYXJjaFBvc3NpYmxlQmlMaW5rcygpO1xyXG4gICAgICB0aGlzLmRpc3BsYXkoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRhYmxlID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3RhYmxlJywgeyBjbHM6ICdjb250ZW50LWxpbmtlci10YWJsZScgfSk7XHJcblxyXG4gICAgY29uc3QgdGhlYWQgPSB0YWJsZS5jcmVhdGVUSGVhZCgpO1xyXG4gICAgY29uc3QgaGVhZGVyUm93ID0gdGhlYWQuaW5zZXJ0Um93KCk7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ05vLic7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ0NvdW50JztcclxuICAgIGhlYWRlclJvdy5pbnNlcnRDZWxsKCkudGV4dENvbnRlbnQgPSAnS2V5d29yZCc7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ1NlbGVjdGVkJztcclxuXHJcbiAgICBjb25zdCBzb3J0ZWRCaUxpbmtzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rc1xyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXHJcbiAgICAgIC5zbGljZSgwLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQpO1xyXG5cclxuICAgIGNvbnN0IHRib2R5ID0gdGFibGUuY3JlYXRlVEJvZHkoKTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzb3J0ZWRCaUxpbmtzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjb25zdCB7IGtleXdvcmQsIGNvdW50LCBpc1NlbGVjdGVkIH0gPSBzb3J0ZWRCaUxpbmtzW2luZGV4XTtcclxuXHJcbiAgICAgIGNvbnN0IGlzQWxyZWFkeUJpTGluayA9IGF3YWl0IHRoaXMuaXNBbHJlYWR5QmlMaW5rKGtleXdvcmQpO1xyXG5cclxuICAgICAgaWYgKCFpc0FscmVhZHlCaUxpbmsgJiYgIXRoaXMuaXNJZ25vcmVkKGtleXdvcmQpKSB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gdGJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IChpbmRleCArIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IGNvdW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IGtleXdvcmQ7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNoZWNrYm94KGtleXdvcmQsIGlzU2VsZWN0ZWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZUJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6ICdVcGRhdGUgYmktZGlyZWN0aW9uYWwgbGluayBmb3Igc2VsZWN0ZWQgb3B0aW9uKHMpJyxcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUJpTGlua3MoKTtcclxuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgIHRoaXMuZGlzcGxheSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaWdub3JlQnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuICAgICAgdGV4dDogJ0lnbm9yZSBzZWxlY3RlZCBvcHRpb24ocyknLFxyXG4gICAgfSk7XHJcbiAgICBpZ25vcmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaWdub3JlU2VsZWN0ZWRPcHRpb25zKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRpc3BsYXlJZ25vcmVkQ29udGVudExpc3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEga2V5d29yZCBpcyBpZ25vcmVkLlxyXG4gICAqIEBwYXJhbSBrZXl3b3JkIC0gVGhlIGtleXdvcmQgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBpZ25vcmVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgaXNJZ25vcmVkKGtleXdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnNvbWUoXHJcbiAgICAgIChpZ25vcmVkQ29udGVudCkgPT4gaWdub3JlZENvbnRlbnQua2V5d29yZCA9PT0ga2V5d29yZFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEga2V5d29yZCBpcyBhbHJlYWR5IGEgYmktbGluayBpbiBhbnkgbm90ZS5cclxuICAgKiBAcGFyYW0ga2V5d29yZCAtIFRoZSBrZXl3b3JkIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgaXQgaXMgYWxyZWFkeSBhIGJpLWxpbmssIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBhc3luYyBpc0FscmVhZHlCaUxpbmsoa2V5d29yZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBjb25zdCB2YXVsdCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdDtcclxuICAgIGNvbnN0IG5vdGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChub3RlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXFtcXFxcWyR7a2V5d29yZH1cXFxcXVxcXFxdYCwgJ2cnKTtcclxuICAgICAgaWYgKGNvbnRlbnQubWF0Y2gocmVnZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBjaGVja2JveCBlbGVtZW50IGZvciBhIGJpLWxpbmsgb3B0aW9uLlxyXG4gICAqIEBwYXJhbSBrZXl3b3JkIC0gVGhlIGtleXdvcmQgZm9yIHRoZSBiaS1saW5rLlxyXG4gICAqIEBwYXJhbSBjaGVja2VkIC0gV2hldGhlciB0aGUgY2hlY2tib3ggaXMgc2VsZWN0ZWQuXHJcbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY2hlY2tib3ggZWxlbWVudC5cclxuICAgKi9cclxuICBjcmVhdGVDaGVja2JveChrZXl3b3JkOiBzdHJpbmcsIGNoZWNrZWQ6IGJvb2xlYW4pOiBIVE1MRWxlbWVudCB7XHJcbiAgICBjb25zdCBjaGVja2JveENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgIGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgY2hlY2tib3hDb250YWluZXIuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xyXG5cclxuICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MubWFwKChiaUxpbmspID0+XHJcbiAgICAgICAgYmlMaW5rLmtleXdvcmQgPT09IGtleXdvcmRcclxuICAgICAgICAgID8geyAuLi5iaUxpbmssIGlzU2VsZWN0ZWQ6IGNoZWNrYm94LmNoZWNrZWQgfVxyXG4gICAgICAgICAgOiBiaUxpbmtcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNoZWNrYm94Q29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlQmlMaW5rcygpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkQmlMaW5rcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MuZmlsdGVyKFxyXG4gICAgICAoYmlMaW5rKSA9PiBiaUxpbmsuaXNTZWxlY3RlZFxyXG4gICAgKTtcclxuICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzLm1hcCgoYmlMaW5rKSA9PlxyXG4gICAgICBzZWxlY3RlZEJpTGlua3Muc29tZSgoeyBrZXl3b3JkIH0pID0+IGJpTGluay5rZXl3b3JkID09PSBrZXl3b3JkKVxyXG4gICAgICAgID8geyAuLi5iaUxpbmssIGlzU2VsZWN0ZWQ6IGZhbHNlIH1cclxuICAgICAgICA6IGJpTGlua1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCB2YXVsdCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdDtcclxuICAgIGNvbnN0IG5vdGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xyXG4gICAgY29uc3QgdG90YWxOb3RlcyA9IG5vdGVzLmxlbmd0aDtcclxuXHJcbiAgICBsZXQgaW5kZXhDb3VudCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkQmlMaW5rIG9mIHNlbGVjdGVkQmlMaW5rcykge1xyXG4gICAgICBjb25zdCB7IGtleXdvcmQgfSA9IHNlbGVjdGVkQmlMaW5rO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhjbHVkZWQobm90ZS5wYXRoKSkge1xyXG4gICAgICAgICAgbGV0IGNvbnRlbnQgPSBhd2FpdCB2YXVsdC5yZWFkKG5vdGUpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgYFxcXFxiJHtrZXl3b3JkLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKX1cXFxcYmAsXHJcbiAgICAgICAgICAgICdnJ1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UocmVnZXgsIGBbWyR7a2V5d29yZH1dXWApO1xyXG5cclxuICAgICAgICAgIGF3YWl0IHZhdWx0Lm1vZGlmeShub3RlLCBjb250ZW50KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpbmRleENvdW50Kys7XHJcbiAgICAgICAgICB0aGlzLnNob3dQcm9ncmVzcyhpbmRleENvdW50LHRvdGFsTm90ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICBcclxuICAgIC8vIGF3YWl0IHRoaXMuc2F2ZURhdGFUb1ZhdWx0KCk7XHJcbiAgICBuZXcgTm90aWNlKCdVcGRhdGUgZmluaXNoZWQhJyk7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm90ZSBwYXRoIGlzIGV4Y2x1ZGVkLlxyXG4gICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIG5vdGUuXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm90ZSBwYXRoIGlzIGV4Y2x1ZGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgaXNFeGNsdWRlZChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxhdGl2ZVBhdGhPZkV4Y2x1ZGVkTm90ZXMgPT09ICcnKSByZXR1cm4gZmFsc2U7XHJcbiAgXHJcbiAgICByZXR1cm4gcGF0aC5pbmNsdWRlcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxhdGl2ZVBhdGhPZkV4Y2x1ZGVkTm90ZXMudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG4gIFxyXG5cclxuICAvKipcclxuICAgKiBJZ25vcmUgdGhlIHNlbGVjdGVkIGJpLWxpbmsgb3B0aW9ucy5cclxuICAgKi9cclxuICBhc3luYyBpZ25vcmVTZWxlY3RlZE9wdGlvbnMoKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzLmZpbHRlcihcclxuICAgICAgKGJpTGluaykgPT4gYmlMaW5rLmlzU2VsZWN0ZWRcclxuICAgICk7XHJcblxyXG4gICAgZm9yIChjb25zdCBzZWxlY3RlZE9wdGlvbiBvZiBzZWxlY3RlZE9wdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyBrZXl3b3JkIH0gPSBzZWxlY3RlZE9wdGlvbjtcclxuICAgICAgLy8gc2V0IHRoZSBpc1NlbGVjdGVkIHN0YXR1cyB0byBmYWxzZVxyXG4gICAgICBzZWxlY3RlZE9wdGlvbi5pc1NlbGVjdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAvLyBhZGQgc2VsZWN0ZWQgb3B0aW9ucyB0byBpZ25vcmVkIGxpc3RcclxuICAgICAgaWYgKFxyXG4gICAgICAgICF0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5zb21lKFxyXG4gICAgICAgICAgKGlnbm9yZWRDb250ZW50KSA9PiBpZ25vcmVkQ29udGVudC5rZXl3b3JkID09PSBrZXl3b3JkXHJcbiAgICAgICAgKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5wdXNoKHNlbGVjdGVkT3B0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBmcm9tIHRoZSBiaS1saW5rcyBhcnJheVxyXG4gICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MuZmlsdGVyKFxyXG4gICAgICAoYmlMaW5rKSA9PiAhYmlMaW5rLmlzU2VsZWN0ZWRcclxuICAgICk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICB0aGlzLmRpc3BsYXkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BsYXkgdGhlIGlnbm9yZWQgY29udGVudCBsaXN0LlxyXG4gICAqL1xyXG4gIGFzeW5jIGRpc3BsYXlJZ25vcmVkQ29udGVudExpc3QoKSB7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cclxuICAgIGNvbnN0IGlnbm9yZWRDb250ZW50U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnSWdub3JlZCBjb250ZW50IGxpc3QnKVxyXG4gICAgICAuc2V0RGVzYygnS2V5d29yZHMgdGhhdCB5b3Ugd2FudCB0byBpZ25vcmUnKTtcclxuXHJcbiAgICBjb25zdCBpZ25vcmVkQ29udGVudFRhYmxlID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3RhYmxlJywge1xyXG4gICAgICBjbHM6ICdjb250ZW50LWxpbmtlci1pZ25vcmVkLWNvbnRlbnQtdGFibGUnLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaWdub3JlZENvbnRlbnRUaGVhZCA9IGlnbm9yZWRDb250ZW50VGFibGUuY3JlYXRlVEhlYWQoKTtcclxuICAgIGNvbnN0IGlnbm9yZWRDb250ZW50SGVhZGVyUm93ID0gaWdub3JlZENvbnRlbnRUaGVhZC5pbnNlcnRSb3coKTtcclxuICAgIGlnbm9yZWRDb250ZW50SGVhZGVyUm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9ICdOby4nO1xyXG4gICAgaWdub3JlZENvbnRlbnRIZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ0NvdW50JztcclxuICAgIGlnbm9yZWRDb250ZW50SGVhZGVyUm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9ICdLZXl3b3JkJztcclxuICAgIGlnbm9yZWRDb250ZW50SGVhZGVyUm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9ICdTZWxlY3RlZCc7XHJcblxyXG4gICAgY29uc3Qgc29ydGVkSWdub3JlZExpc3QgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5zb3J0KFxyXG4gICAgICAoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnRcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgaWdub3JlZENvbnRlbnRUYm9keSA9IGlnbm9yZWRDb250ZW50VGFibGUuY3JlYXRlVEJvZHkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkSWdub3JlZExpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgeyBrZXl3b3JkLCBjb3VudCwgaXNTZWxlY3RlZCB9ID0gc29ydGVkSWdub3JlZExpc3RbaV07XHJcblxyXG4gICAgICBjb25zdCByb3cgPSBpZ25vcmVkQ29udGVudFRib2R5Lmluc2VydFJvdygpO1xyXG4gICAgICByb3cuaW5zZXJ0Q2VsbCgwKS50ZXh0Q29udGVudCA9IChpICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgcm93Lmluc2VydENlbGwoMSkudGV4dENvbnRlbnQgPSBjb3VudCA/IGNvdW50LnRvU3RyaW5nKCkgOiAnJztcclxuICAgICAgcm93Lmluc2VydENlbGwoMikudGV4dENvbnRlbnQgPSBrZXl3b3JkO1xyXG4gICAgICByb3cuaW5zZXJ0Q2VsbCgzKS5hcHBlbmRDaGlsZChcclxuICAgICAgICB0aGlzLmNyZWF0ZUlnbm9yZWRDaGVja2JveChrZXl3b3JkLCBpc1NlbGVjdGVkKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGlnbm9yZWRDb250ZW50VGFibGUpO1xyXG5cclxuICAgIGNvbnN0IHJlbW92ZUJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6ICdSZW1vdmUgc2VsZWN0ZWQgb3B0aW9uKHMpIGZyb20gaWdub3JlZCBjb250ZW50IGxpc3QnLFxyXG4gICAgfSk7XHJcbiAgICByZW1vdmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBmcm9tIHRoZSBpZ25vcmVkIGNvbnRlbnQgbGlzdFxyXG4gICAgICB0aGlzLnJlbW92ZUZyb21JZ25vcmVkTGlzdCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBjaGVja2JveCBlbGVtZW50IGZvciBhbiBpZ25vcmVkIG9wdGlvbi5cclxuICAgKiBAcGFyYW0ga2V5d29yZCAtIFRoZSBrZXl3b3JkIGZvciB0aGUgaWdub3JlZCBvcHRpb24uXHJcbiAgICogQHBhcmFtIGNoZWNrZWQgLSBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyBzZWxlY3RlZC5cclxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjaGVja2JveCBlbGVtZW50LlxyXG4gICAqL1xyXG4gIGNyZWF0ZUlnbm9yZWRDaGVja2JveChrZXl3b3JkOiBzdHJpbmcsIGNoZWNrZWQ6IGJvb2xlYW4pOiBIVE1MRWxlbWVudCB7XHJcbiAgICBjb25zdCBjaGVja2JveENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgIGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgY2hlY2tib3hDb250YWluZXIuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xyXG5cclxuICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaWdub3JlZENvbnRlbnQgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5tYXAoXHJcbiAgICAgICAgKGlnbm9yZWRDb250ZW50KSA9PlxyXG4gICAgICAgICAgaWdub3JlZENvbnRlbnQua2V5d29yZCA9PT0ga2V5d29yZFxyXG4gICAgICAgICAgICA/IHsgLi4uaWdub3JlZENvbnRlbnQsIGlzU2VsZWN0ZWQ6IGNoZWNrYm94LmNoZWNrZWQgfVxyXG4gICAgICAgICAgICA6IGlnbm9yZWRDb250ZW50XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjaGVja2JveENvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBmcm9tIHRoZSBpZ25vcmVkIGNvbnRlbnQgbGlzdC5cclxuICAgKi9cclxuICBhc3luYyByZW1vdmVGcm9tSWdub3JlZExpc3QoKSB7XHJcbiAgICAvLyBHZXQgc2VsZWN0ZWQgaWdub3JlZCBvcHRpb25zXHJcbiAgICBjb25zdCBzZWxlY3RlZElnbm9yZWRPcHRpb25zID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuaWdub3JlZENvbnRlbnQuZmlsdGVyKFxyXG4gICAgICAoaWdub3JlZENvbnRlbnQpID0+IHtcclxuICAgICAgICByZXR1cm4gaWdub3JlZENvbnRlbnQuaXNTZWxlY3RlZDtcclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkSWdub3JlZE9wdGlvbiBvZiBzZWxlY3RlZElnbm9yZWRPcHRpb25zKSB7XHJcbiAgICAgIGNvbnN0IHsga2V5d29yZCB9ID0gc2VsZWN0ZWRJZ25vcmVkT3B0aW9uO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGZyb20gaWdub3JlZCBjb250ZW50IGxpc3RcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5maW5kSW5kZXgoXHJcbiAgICAgICAgKGlnbm9yZWRDb250ZW50KSA9PiBpZ25vcmVkQ29udGVudC5rZXl3b3JkID09PSBrZXl3b3JkXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5KCk7IC8vIFJlZnJlc2ggdGhlIGlnbm9yZWQgY29udGVudCBsaXN0XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaG93UHJvZ3Jlc3MoaW5kZXhDb3VudDogbnVtYmVyLCB0b3RhbE51bWJlcjogbnVtYmVyKVxyXG4gIHtcclxuICAgICAgaWYgKGluZGV4Q291bnQgPT0gMSB8fCBcclxuICAgICAgICBpbmRleENvdW50ICUgMTAwID09IDAgfHwgXHJcbiAgICAgICAgaW5kZXhDb3VudCA9PSB0b3RhbE51bWJlcikge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gYFVwZGF0aW5nOiAke2luZGV4Q291bnR9IG9mICR7dG90YWxOdW1iZXJ9YDtcclxuICAgICAgbmV3IE5vdGljZShtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUErRDtBQXFCL0QsSUFBcUIsc0JBQXJCLGNBQWlELHVCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPdEQsTUFBTSxTQUFTO0FBQ2IsVUFBTSxLQUFLLGFBQWE7QUFFeEIsWUFBUSxJQUFJLCtCQUErQjtBQUUzQyxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNwQixjQUFNLEtBQUssc0JBQXNCO0FBQ2pDLGNBQU0sS0FBSyxhQUFhO0FBQUEsTUFDMUI7QUFBQSxJQUNGLENBQUM7QUFFRCxTQUFLLGNBQWMsSUFBSSx3QkFBd0IsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLEVBQ2hFO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLGVBQWU7QUFDbkIsU0FBSyxXQUFXLE9BQU87QUFBQSxNQUNyQixDQUFDO0FBQUEsTUFDRDtBQUFBLFFBQ0UsU0FBUyxDQUFDO0FBQUEsUUFDVixjQUFjO0FBQUEsUUFDZCxnQkFBZ0IsQ0FBQztBQUFBLFFBQ2pCLDZCQUE2QjtBQUFBLE1BQy9CO0FBQUEsTUFDQSxNQUFNLEtBQUssU0FBUztBQUFBLElBQ3RCO0FBQUEsRUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxlQUFlO0FBQ25CLFNBQUss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QUFVO0FBQUEsTUFDbEQsTUFBTTtBQUFBLElBQ1IsQ0FBQztBQUNELGlCQUFhLGlCQUFpQixTQUFTLFlBQVk7QUFFakQsV0FBSyxzQkFBc0I7QUFBQSxJQUM3QixDQUFDO0FBQUEsRUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBUUEsc0JBQXNCLFNBQWlCLFNBQStCO0FBQ3BFLFVBQU0sb0JBQW9CLFNBQVMsY0FBYyxPQUFPO0FBQ3hELFVBQU0sV0FBVyxTQUFTLGNBQWMsT0FBTztBQUMvQyxhQUFTLE9BQU87QUFDaEIsYUFBUyxVQUFVO0FBQ25CLHNCQUFrQixZQUFZLFFBQVE7QUFFdEMsYUFBUyxpQkFBaUIsVUFBVSxZQUFZO0FBQzlDLFdBQUssT0FBTyxTQUFTLGlCQUFpQixLQUFLLE9BQU8sU0FBUyxlQUFlO0FBQUEsUUFDeEUsQ0FBQyxtQkFDQyxlQUFlLFlBQVksVUFDdkIsRUFBRSxHQUFHLGdCQUFnQixZQUFZLFNBQVMsUUFBUSxJQUNsRDtBQUFBLE1BQ1I7QUFFQSxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDakMsQ0FBQztBQUVELFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLHdCQUF3QjtBQUU1QixVQUFNLHlCQUF5QixLQUFLLE9BQU8sU0FBUyxlQUFlO0FBQUEsTUFDakUsQ0FBQyxtQkFBbUI7QUFDbEIsZUFBTyxlQUFlO0FBQUEsTUFDeEI7QUFBQSxJQUNGO0FBRUEsZUFBVyx5QkFBeUIsd0JBQXdCO0FBQzFELFlBQU0sRUFBRSxRQUFRLElBQUk7QUFHcEIsWUFBTSxRQUFRLEtBQUssT0FBTyxTQUFTLGVBQWU7QUFBQSxRQUNoRCxDQUFDLG1CQUFtQixlQUFlLFlBQVk7QUFBQSxNQUNqRDtBQUNBLFVBQUksVUFBVSxJQUFJO0FBQ2hCLGFBQUssT0FBTyxTQUFTLGVBQWUsT0FBTyxPQUFPLENBQUM7QUFBQSxNQUNyRDtBQUFBLElBQ0Y7QUFFQSxVQUFNLEtBQUssT0FBTyxhQUFhO0FBRS9CLFNBQUssUUFBUTtBQUFBLEVBQ2Y7QUFBQSxFQUVBLE1BQU0sYUFBYSxZQUFvQixhQUN2QztBQUNJLFFBQUksY0FBYyxLQUNoQixhQUFhLE9BQU8sS0FDcEIsY0FBYyxhQUFhO0FBQzdCLFlBQU0sVUFBVSxhQUFhLGlCQUFpQjtBQUM5QyxVQUFJLHVCQUFPLE9BQU87QUFBQSxJQUNwQjtBQUFBLEVBQ0Y7QUFDRjsiLAogICJuYW1lcyI6IFtdCn0K
