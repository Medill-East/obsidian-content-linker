/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ContentLinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ContentLinkerPlugin = class extends import_obsidian.Plugin {
  /**
   * Plugin onload event handler.
   */
  async onload() {
    await this.loadSettings();
    console.log("Loading Content Linker plugin");
    this.addCommand({
      id: "search-possible-bi-directional-links",
      name: "Search possible bi-directional links in vault",
      callback: async () => {
        await this.searchPossibleBiLinks();
        await this.saveSettings();
      }
    });
    this.addSettingTab(new ContentLinkerSettingTab(this.app, this));
  }
  /**
   * Load plugin data from storage.
   */
  async loadSettings() {
    this.settings = Object.assign(
      {},
      {
        biLinks: [],
        optionsCount: 10,
        ignoredContent: [],
        relativePathOfExcludedNotes: ""
      },
      await this.loadData()
    );
  }
  /**
   * Save plugin data to storage.
   */
  async saveSettings() {
    this.saveData(this.settings);
  }
  /**
   * Search for possible bi-links in the vault.
   */
  async searchPossibleBiLinks() {
    const vault = this.app.vault;
    const notes = this.settings.relativePathOfExcludedNotes === "" ? vault.getMarkdownFiles() : vault.getMarkdownFiles().filter((file) => !file.path.includes(this.settings.relativePathOfExcludedNotes.toString()));
    const existingBiLinks = /* @__PURE__ */ new Set();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const biLinkKeywords = content.match(/\[\[(.+?)\]\]/g) || [];
      for (const biLink of biLinkKeywords) {
        const keyword = biLink.slice(2, -2);
        existingBiLinks.add(keyword);
      }
    }
    const potentialBiLinks = /* @__PURE__ */ new Map();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const uniqueKeywords = content.match(/\b\w+\b/g) || [];
      for (const keyword of uniqueKeywords) {
        if (!potentialBiLinks.has(keyword) && !this.settings.biLinks.some((biLink) => biLink.keyword === keyword) && !existingBiLinks.has(keyword) && !content.includes(`[[${keyword}]]`) && !this.settings.ignoredContent.some(
          (ignoredContent) => ignoredContent.keyword === keyword
        )) {
          potentialBiLinks.set(keyword, 1);
        } else {
          potentialBiLinks.set(
            keyword,
            (potentialBiLinks.get(keyword) || 0) + 1
          );
        }
      }
    }
    this.settings.biLinks = Array.from(potentialBiLinks.entries()).map(
      ([keyword, count]) => ({
        keyword,
        count,
        isSelected: false
      })
    );
    await this.saveSettings();
    new import_obsidian.Notice("Search finished!");
  }
};
var ContentLinkerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const relativePathExclusion = new import_obsidian.Setting(containerEl).setName("Relative path of excluded notes").setDesc("Enter a relative path:");
    relativePathExclusion.addText((input) => input.setPlaceholder("Relative path of exluded notes").setValue(this.plugin.settings.relativePathOfExcludedNotes.toString()).onChange(async (value) => {
      this.plugin.settings.relativePathOfExcludedNotes = value;
      await this.plugin.saveSettings();
    }));
    const searchButton = containerEl.createEl("button", {
      text: "Search possible bi-directional links in vault"
    });
    searchButton.addEventListener("click", async () => {
      await this.plugin.searchPossibleBiLinks();
      await this.display();
    });
    new import_obsidian.Setting(containerEl).setName("Possible bi-directional content").setDesc("Enter a number:").addText(
      (text) => text.setValue(this.plugin.settings.optionsCount.toString()).onChange(async (value) => {
        const parsedValue = parseFloat(value);
        if (!isNaN(parsedValue)) {
          this.plugin.settings.optionsCount = parsedValue;
        }
      })
    );
    const countButton = containerEl.createEl("button", {
      text: "Update number of search results"
    });
    countButton.addEventListener("click", async () => {
      await this.plugin.searchPossibleBiLinks();
      await this.display();
    });
    const table = containerEl.createEl("table", { cls: "content-linker-table" });
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    headerRow.insertCell().textContent = "No.";
    headerRow.insertCell().textContent = "Count";
    headerRow.insertCell().textContent = "Keyword";
    headerRow.insertCell().textContent = "Selected";
    const sortedBiLinks = this.plugin.settings.biLinks.sort((a, b) => b.count - a.count).slice(0, this.plugin.settings.optionsCount);
    const tbody = table.createTBody();
    for (let index = 0; index < sortedBiLinks.length; index++) {
      const { keyword, count, isSelected } = sortedBiLinks[index];
      const isAlreadyBiLink = await this.isAlreadyBiLink(keyword);
      if (!isAlreadyBiLink && !this.isIgnored(keyword)) {
        const row = tbody.insertRow();
        row.insertCell().textContent = (index + 1).toString();
        row.insertCell().textContent = count.toString();
        row.insertCell().textContent = keyword;
        row.insertCell().appendChild(this.createCheckbox(keyword, isSelected));
      }
    }
    const updateButton = containerEl.createEl("button", {
      text: "Update bi-directional link for selected option(s)"
    });
    updateButton.addEventListener("click", async () => {
      await this.updateBiLinks();
      await this.plugin.searchPossibleBiLinks();
      await this.display();
    });
    const ignoreButton = containerEl.createEl("button", {
      text: "Ignore selected option(s)"
    });
    ignoreButton.addEventListener("click", async () => {
      await this.ignoreSelectedOptions();
    });
    await this.displayIgnoredContentList();
    await this.displayBiDirectionalLinksList();
  }
  /**
   * Check if a keyword is ignored.
   * @param keyword - The keyword to check.
   * @returns True if ignored, false otherwise.
   */
  isIgnored(keyword) {
    return this.plugin.settings.ignoredContent.some(
      (ignoredContent) => ignoredContent.keyword === keyword
    );
  }
  /**
   * Check if a keyword is already a bi-link in any note.
   * @param keyword - The keyword to check.
   * @returns True if it is already a bi-link, false otherwise.
   */
  async isAlreadyBiLink(keyword) {
    const vault = this.plugin.app.vault;
    const notes = vault.getMarkdownFiles();
    for (const note of notes) {
      const content = await vault.cachedRead(note);
      const regex = new RegExp(`\\[\\[${keyword}\\]\\]`, "g");
      if (content.match(regex)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Create a checkbox element for a bi-link option.
   * @param keyword - The keyword for the bi-link.
   * @param checked - Whether the checkbox is selected.
   * @returns The created checkbox element.
   */
  createCheckbox(keyword, checked) {
    const checkboxContainer = document.createElement("label");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = checked;
    checkboxContainer.appendChild(checkbox);
    checkbox.addEventListener("change", async () => {
      this.plugin.settings.biLinks = this.plugin.settings.biLinks.map(
        (biLink) => biLink.keyword === keyword ? { ...biLink, isSelected: checkbox.checked } : biLink
      );
      await this.plugin.saveSettings();
    });
    return checkboxContainer;
  }
  async updateBiLinks() {
    const selectedBiLinks = this.plugin.settings.biLinks.filter(
      (biLink) => biLink.isSelected
    );
    const vault = this.plugin.app.vault;
    const notes = vault.getMarkdownFiles();
    const totalNotes = notes.length;
    let indexCount = 0;
    const keywordToRegex = /* @__PURE__ */ new Map();
    for (const selectedBiLink of selectedBiLinks) {
      const { keyword } = selectedBiLink;
      const regexPattern = `\\b${keyword.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\b`;
      keywordToRegex.set(keyword, new RegExp(regexPattern, "g"));
    }
    for (const note of notes) {
      if (!this.isExcluded(note.path)) {
        let content = await vault.read(note);
        let updatedContent = content;
        for (const selectedBiLink of selectedBiLinks) {
          const { keyword } = selectedBiLink;
          const regex = keywordToRegex.get(keyword);
          if (regex) {
            updatedContent = updatedContent.replace(regex, `[[${keyword}]]`);
          }
        }
        if (updatedContent !== content) {
          await vault.modify(note, updatedContent);
        }
        indexCount++;
        this.showProgress(indexCount, totalNotes);
      }
    }
    this.plugin.settings.biLinks = this.plugin.settings.biLinks.map(
      (biLink) => selectedBiLinks.some(({ keyword }) => biLink.keyword === keyword) ? { ...biLink, isSelected: false } : biLink
    );
    await this.plugin.saveSettings();
    new import_obsidian.Notice("Update finished!");
  }
  /**
   * Check if a note path is excluded.
   * @param path - The path of the note.
   * @returns True if the note path is excluded, false otherwise.
   */
  isExcluded(path) {
    if (this.plugin.settings.relativePathOfExcludedNotes === "")
      return false;
    return path.includes(this.plugin.settings.relativePathOfExcludedNotes.toString());
  }
  /**
   * Ignore the selected bi-link options.
   */
  async ignoreSelectedOptions() {
    const selectedOptions = this.plugin.settings.biLinks.filter(
      (biLink) => biLink.isSelected
    );
    for (const selectedOption of selectedOptions) {
      const { keyword } = selectedOption;
      selectedOption.isSelected = false;
      if (!this.plugin.settings.ignoredContent.some(
        (ignoredContent) => ignoredContent.keyword === keyword
      )) {
        this.plugin.settings.ignoredContent.push(selectedOption);
      }
    }
    this.plugin.settings.biLinks = this.plugin.settings.biLinks.filter(
      (biLink) => !biLink.isSelected
    );
    await this.plugin.saveSettings();
    await this.plugin.searchPossibleBiLinks();
    await this.display();
  }
  /**
   * Display the ignored content list.
   */
  async displayIgnoredContentList() {
    const { containerEl } = this;
    const ignoredContentSetting = new import_obsidian.Setting(containerEl).setName("Ignored content list").setDesc("Keywords that you want to ignore");
    const ignoredContentTable = containerEl.createEl("table", {
      cls: "content-linker-ignored-content-table"
    });
    const ignoredContentThead = ignoredContentTable.createTHead();
    const ignoredContentHeaderRow = ignoredContentThead.insertRow();
    ignoredContentHeaderRow.insertCell().textContent = "No.";
    ignoredContentHeaderRow.insertCell().textContent = "Count";
    ignoredContentHeaderRow.insertCell().textContent = "Keyword";
    ignoredContentHeaderRow.insertCell().textContent = "Selected";
    const sortedIgnoredList = this.plugin.settings.ignoredContent.sort(
      (a, b) => b.count - a.count
    );
    const ignoredContentTbody = ignoredContentTable.createTBody();
    for (let i = 0; i < sortedIgnoredList.length; i++) {
      const { keyword, count, isSelected } = sortedIgnoredList[i];
      const row = ignoredContentTbody.insertRow();
      row.insertCell(0).textContent = (i + 1).toString();
      row.insertCell(1).textContent = count ? count.toString() : "";
      row.insertCell(2).textContent = keyword;
      row.insertCell(3).appendChild(
        this.createIgnoredCheckbox(keyword, isSelected)
      );
    }
    containerEl.appendChild(ignoredContentTable);
    const removeButton = containerEl.createEl("button", {
      text: "Remove selected option(s) from ignored content list"
    });
    removeButton.addEventListener("click", async () => {
      this.removeFromIgnoredList();
    });
  }
  /**
   * Create a checkbox element for an ignored option.
   * @param keyword - The keyword for the ignored option.
   * @param checked - Whether the checkbox is selected.
   * @returns The created checkbox element.
   */
  createIgnoredCheckbox(keyword, checked) {
    const checkboxContainer = document.createElement("label");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = checked;
    checkboxContainer.appendChild(checkbox);
    checkbox.addEventListener("change", async () => {
      this.plugin.settings.ignoredContent = this.plugin.settings.ignoredContent.map(
        (ignoredContent) => ignoredContent.keyword === keyword ? { ...ignoredContent, isSelected: checkbox.checked } : ignoredContent
      );
      await this.plugin.saveSettings();
    });
    return checkboxContainer;
  }
  /**
   * Remove the selected options from the ignored content list.
   */
  async removeFromIgnoredList() {
    const selectedIgnoredOptions = this.plugin.settings.ignoredContent.filter(
      (ignoredContent) => {
        return ignoredContent.isSelected;
      }
    );
    for (const selectedIgnoredOption of selectedIgnoredOptions) {
      const { keyword } = selectedIgnoredOption;
      const index = this.plugin.settings.ignoredContent.findIndex(
        (ignoredContent) => ignoredContent.keyword === keyword
      );
      if (index !== -1) {
        this.plugin.settings.ignoredContent.splice(index, 1);
      }
    }
    await this.plugin.saveSettings();
    await this.display();
  }
  async showProgress(indexCount, totalNumber) {
    if (indexCount == 1 || indexCount % Math.floor(totalNumber / 10) == 0 || indexCount == totalNumber) {
      const message = `Updating: ${indexCount} of ${totalNumber}`;
      new import_obsidian.Notice(message);
    }
  }
  async displayBiDirectionalLinksList() {
    const { containerEl } = this;
    const linkedContentSetting = new import_obsidian.Setting(containerEl).setName("Linked content list").setDesc("Content that is already bi-directional-linked. Count including non-bi-directional-linked format");
    const linkedContentTable = containerEl.createEl("table", {
      cls: "content-linker-linked-content-table"
    });
    const thead = linkedContentTable.createTHead();
    const headerRow = thead.insertRow();
    headerRow.insertCell().textContent = "No.";
    headerRow.insertCell().textContent = "Count";
    headerRow.insertCell().textContent = "Keyword";
    headerRow.insertCell().textContent = "Selected";
    const sortedBiLinks = this.plugin.settings.biLinks.sort((a, b) => b.count - a.count);
    const tbody = linkedContentTable.createTBody();
    const batchSize = 100;
    let indexCount = 0;
    const processBatch = async () => {
      for (let i = 0; i < batchSize && indexCount < sortedBiLinks.length; i++) {
        const { keyword, count, isSelected } = sortedBiLinks[indexCount];
        const isAlreadyBiLink = await this.isAlreadyBiLink(keyword);
        if (isAlreadyBiLink && !this.isIgnored(keyword)) {
          const row = tbody.insertRow();
          row.insertCell().textContent = (indexCount + 1).toString();
          row.insertCell().textContent = count.toString();
          row.insertCell().textContent = keyword;
          row.insertCell().appendChild(this.createCheckbox(keyword, isSelected));
        }
        indexCount++;
        this.showProgress(indexCount, sortedBiLinks.length);
      }
      if (indexCount < sortedBiLinks.length) {
        setTimeout(processBatch, 0);
      } else {
        containerEl.appendChild(linkedContentTable);
        const removeButton = containerEl.createEl("button", {
          text: "Remove bi-directional links for selected option(s)"
        });
        removeButton.addEventListener("click", async () => {
          await this.removeSelectedBiLinks();
        });
      }
    };
    processBatch();
  }
  async removeSelectedBiLinks() {
    const selectedBiLinks = this.plugin.settings.biLinks.filter(
      (biLink) => biLink.isSelected
    );
    const selectedKeywords = new Set(
      selectedBiLinks.map((biLink) => biLink.keyword)
    );
    const vault = this.app.vault;
    const notes = this.plugin.settings.relativePathOfExcludedNotes === "" ? vault.getMarkdownFiles() : vault.getMarkdownFiles().filter((file) => !file.path.includes(this.plugin.settings.relativePathOfExcludedNotes.toString()));
    let indexCount = 0;
    for (const note of notes) {
      let content = await vault.read(note);
      let modified = false;
      for (const selectedKeyword of selectedKeywords) {
        const regex = new RegExp(
          `\\[\\[${selectedKeyword}\\]\\]`,
          "g"
        );
        if (content.match(regex)) {
          content = content.replace(regex, selectedKeyword);
          modified = true;
        }
      }
      if (modified) {
        await vault.modify(note, content);
        indexCount++;
        this.showProgress(indexCount, notes.length);
      }
    }
    this.plugin.settings.biLinks = this.plugin.settings.biLinks.filter(
      (biLink) => !biLink.isSelected
    );
    await this.plugin.saveSettings();
    new import_obsidian.Notice("Selected bi-directional links removed!");
    await this.plugin.searchPossibleBiLinks();
    await this.display();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmludGVyZmFjZSBCaUxpbmsge1xyXG4gIGtleXdvcmQ6IHN0cmluZztcclxuICBjb3VudDogbnVtYmVyO1xyXG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBJZ25vcmVkQ29udGVudCB7XHJcbiAga2V5d29yZDogc3RyaW5nO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgaXNTZWxlY3RlZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIENvbnRlbnRMaW5rZXJQbHVnaW5TZXR0aW5ncyB7XHJcbiAgYmlMaW5rczogQmlMaW5rW107XHJcbiAgb3B0aW9uc0NvdW50OiBudW1iZXI7XHJcbiAgaWdub3JlZENvbnRlbnQ6IElnbm9yZWRDb250ZW50W107XHJcbiAgcmVsYXRpdmVQYXRoT2ZFeGNsdWRlZE5vdGVzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRMaW5rZXJQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cclxuICBzZXR0aW5nczogQ29udGVudExpbmtlclBsdWdpblNldHRpbmdzO1xyXG5cclxuICAvKipcclxuICAgKiBQbHVnaW4gb25sb2FkIGV2ZW50IGhhbmRsZXIuXHJcbiAgICovXHJcbiAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnTG9hZGluZyBDb250ZW50IExpbmtlciBwbHVnaW4nKTtcclxuXHJcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xyXG4gICAgICBpZDogJ3NlYXJjaC1wb3NzaWJsZS1iaS1kaXJlY3Rpb25hbC1saW5rcycsXHJcbiAgICAgIG5hbWU6ICdTZWFyY2ggcG9zc2libGUgYmktZGlyZWN0aW9uYWwgbGlua3MgaW4gdmF1bHQnLFxyXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTsgLy8gU2F2ZSBkYXRhIGFmdGVyIG1ha2luZyBjaGFuZ2VzXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IENvbnRlbnRMaW5rZXJTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIHBsdWdpbiBkYXRhIGZyb20gc3RvcmFnZS5cclxuICAgKi9cclxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcclxuICAgICAge30sXHJcbiAgICAgIHtcclxuICAgICAgICBiaUxpbmtzOiBbXSxcclxuICAgICAgICBvcHRpb25zQ291bnQ6IDEwLFxyXG4gICAgICAgIGlnbm9yZWRDb250ZW50OiBbXSxcclxuICAgICAgICByZWxhdGl2ZVBhdGhPZkV4Y2x1ZGVkTm90ZXM6ICcnLFxyXG4gICAgICB9LFxyXG4gICAgICBhd2FpdCB0aGlzLmxvYWREYXRhKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIHBsdWdpbiBkYXRhIHRvIHN0b3JhZ2UuXHJcbiAgICovXHJcbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlYXJjaCBmb3IgcG9zc2libGUgYmktbGlua3MgaW4gdGhlIHZhdWx0LlxyXG4gICAqL1xyXG4gIGFzeW5jIHNlYXJjaFBvc3NpYmxlQmlMaW5rcygpIHtcclxuICAgIGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcblxyXG4gICAgY29uc3Qgbm90ZXMgPSB0aGlzLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3RlcyA9PT0gJycgPyB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkgOiB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkuZmlsdGVyKGZpbGUgPT4gIWZpbGUucGF0aC5pbmNsdWRlcyh0aGlzLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3Rlcy50b1N0cmluZygpKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGV4aXN0aW5nQmlMaW5rcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChub3RlKTtcclxuXHJcbiAgICAgIGNvbnN0IGJpTGlua0tleXdvcmRzID0gY29udGVudC5tYXRjaCgvXFxbXFxbKC4rPylcXF1cXF0vZykgfHwgW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGJpTGluayBvZiBiaUxpbmtLZXl3b3Jkcykge1xyXG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSBiaUxpbmsuc2xpY2UoMiwgLTIpO1xyXG4gICAgICAgIGV4aXN0aW5nQmlMaW5rcy5hZGQoa2V5d29yZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwb3RlbnRpYWxCaUxpbmtzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXMpIHtcclxuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQobm90ZSk7XHJcblxyXG4gICAgICBjb25zdCB1bmlxdWVLZXl3b3JkcyA9IGNvbnRlbnQubWF0Y2goL1xcYlxcdytcXGIvZykgfHwgW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2YgdW5pcXVlS2V5d29yZHMpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhcG90ZW50aWFsQmlMaW5rcy5oYXMoa2V5d29yZCkgJiZcclxuICAgICAgICAgICF0aGlzLnNldHRpbmdzLmJpTGlua3Muc29tZSgoYmlMaW5rKSA9PiBiaUxpbmsua2V5d29yZCA9PT0ga2V5d29yZCkgJiZcclxuICAgICAgICAgICFleGlzdGluZ0JpTGlua3MuaGFzKGtleXdvcmQpICYmXHJcbiAgICAgICAgICAhY29udGVudC5pbmNsdWRlcyhgW1ske2tleXdvcmR9XV1gKSAmJlxyXG4gICAgICAgICAgIXRoaXMuc2V0dGluZ3MuaWdub3JlZENvbnRlbnQuc29tZShcclxuICAgICAgICAgICAgKGlnbm9yZWRDb250ZW50KSA9PiBpZ25vcmVkQ29udGVudC5rZXl3b3JkID09PSBrZXl3b3JkXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBwb3RlbnRpYWxCaUxpbmtzLnNldChrZXl3b3JkLCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG90ZW50aWFsQmlMaW5rcy5zZXQoXHJcbiAgICAgICAgICAgIGtleXdvcmQsXHJcbiAgICAgICAgICAgIChwb3RlbnRpYWxCaUxpbmtzLmdldChrZXl3b3JkKSB8fCAwKSArIDFcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXR0aW5ncy5iaUxpbmtzID0gQXJyYXkuZnJvbShwb3RlbnRpYWxCaUxpbmtzLmVudHJpZXMoKSkubWFwKFxyXG4gICAgICAoW2tleXdvcmQsIGNvdW50XSkgPT4gKHtcclxuICAgICAgICBrZXl3b3JkLFxyXG4gICAgICAgIGNvdW50LFxyXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuICAgIG5ldyBOb3RpY2UoJ1NlYXJjaCBmaW5pc2hlZCEnKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENvbnRlbnRMaW5rZXJTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBDb250ZW50TGlua2VyUGx1Z2luO1xyXG5cclxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBDb250ZW50TGlua2VyUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRpc3BsYXkoKSB7XHJcblxyXG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgIC8vIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0V4Y2x1ZGUgbm90ZXMgd2l0aCByZWxhdGl2ZSBwYXRoJyB9KTtcclxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aEV4Y2x1c2lvbiA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZSgnUmVsYXRpdmUgcGF0aCBvZiBleGNsdWRlZCBub3RlcycpXHJcbiAgICAgIC5zZXREZXNjKCdFbnRlciBhIHJlbGF0aXZlIHBhdGg6JylcclxuICAgIHJlbGF0aXZlUGF0aEV4Y2x1c2lvbi5hZGRUZXh0KGlucHV0ID0+IGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignUmVsYXRpdmUgcGF0aCBvZiBleGx1ZGVkIG5vdGVzJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3Rlcy50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXRpdmVQYXRoT2ZFeGNsdWRlZE5vdGVzID0gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcblxyXG4gICAgY29uc3Qgc2VhcmNoQnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuICAgICAgdGV4dDogJ1NlYXJjaCBwb3NzaWJsZSBiaS1kaXJlY3Rpb25hbCBsaW5rcyBpbiB2YXVsdCcsXHJcbiAgICB9KTtcclxuICAgIHNlYXJjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKCdQb3NzaWJsZSBiaS1kaXJlY3Rpb25hbCBjb250ZW50JylcclxuICAgICAgLnNldERlc2MoJ0VudGVyIGEgbnVtYmVyOicpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQudG9TdHJpbmcoKSlcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQgPSBwYXJzZWRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICBjb25zdCBjb3VudEJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6ICdVcGRhdGUgbnVtYmVyIG9mIHNlYXJjaCByZXN1bHRzJyxcclxuICAgIH0pO1xyXG4gICAgY291bnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNlYXJjaFBvc3NpYmxlQmlMaW5rcygpO1xyXG4gICAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRhYmxlID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3RhYmxlJywgeyBjbHM6ICdjb250ZW50LWxpbmtlci10YWJsZScgfSk7XHJcblxyXG4gICAgY29uc3QgdGhlYWQgPSB0YWJsZS5jcmVhdGVUSGVhZCgpO1xyXG4gICAgY29uc3QgaGVhZGVyUm93ID0gdGhlYWQuaW5zZXJ0Um93KCk7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ05vLic7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ0NvdW50JztcclxuICAgIGhlYWRlclJvdy5pbnNlcnRDZWxsKCkudGV4dENvbnRlbnQgPSAnS2V5d29yZCc7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ1NlbGVjdGVkJztcclxuXHJcbiAgICBjb25zdCBzb3J0ZWRCaUxpbmtzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rc1xyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXHJcbiAgICAgIC5zbGljZSgwLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcHRpb25zQ291bnQpO1xyXG5cclxuICAgIGNvbnN0IHRib2R5ID0gdGFibGUuY3JlYXRlVEJvZHkoKTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzb3J0ZWRCaUxpbmtzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjb25zdCB7IGtleXdvcmQsIGNvdW50LCBpc1NlbGVjdGVkIH0gPSBzb3J0ZWRCaUxpbmtzW2luZGV4XTtcclxuXHJcbiAgICAgIGNvbnN0IGlzQWxyZWFkeUJpTGluayA9IGF3YWl0IHRoaXMuaXNBbHJlYWR5QmlMaW5rKGtleXdvcmQpO1xyXG5cclxuICAgICAgaWYgKCFpc0FscmVhZHlCaUxpbmsgJiYgIXRoaXMuaXNJZ25vcmVkKGtleXdvcmQpKSB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gdGJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IChpbmRleCArIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IGNvdW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IGtleXdvcmQ7XHJcbiAgICAgICAgcm93Lmluc2VydENlbGwoKS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNoZWNrYm94KGtleXdvcmQsIGlzU2VsZWN0ZWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZUJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgIHRleHQ6ICdVcGRhdGUgYmktZGlyZWN0aW9uYWwgbGluayBmb3Igc2VsZWN0ZWQgb3B0aW9uKHMpJyxcclxuICAgIH0pO1xyXG4gICAgdXBkYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUJpTGlua3MoKTtcclxuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaWdub3JlQnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuICAgICAgdGV4dDogJ0lnbm9yZSBzZWxlY3RlZCBvcHRpb24ocyknLFxyXG4gICAgfSk7XHJcbiAgICBpZ25vcmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaWdub3JlU2VsZWN0ZWRPcHRpb25zKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmRpc3BsYXlJZ25vcmVkQ29udGVudExpc3QoKTtcclxuICAgIGF3YWl0IHRoaXMuZGlzcGxheUJpRGlyZWN0aW9uYWxMaW5rc0xpc3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEga2V5d29yZCBpcyBpZ25vcmVkLlxyXG4gICAqIEBwYXJhbSBrZXl3b3JkIC0gVGhlIGtleXdvcmQgdG8gY2hlY2suXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiBpZ25vcmVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgaXNJZ25vcmVkKGtleXdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnNvbWUoXHJcbiAgICAgIChpZ25vcmVkQ29udGVudCkgPT4gaWdub3JlZENvbnRlbnQua2V5d29yZCA9PT0ga2V5d29yZFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEga2V5d29yZCBpcyBhbHJlYWR5IGEgYmktbGluayBpbiBhbnkgbm90ZS5cclxuICAgKiBAcGFyYW0ga2V5d29yZCAtIFRoZSBrZXl3b3JkIHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm5zIFRydWUgaWYgaXQgaXMgYWxyZWFkeSBhIGJpLWxpbmssIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBhc3luYyBpc0FscmVhZHlCaUxpbmsoa2V5d29yZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBjb25zdCB2YXVsdCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdDtcclxuICAgIGNvbnN0IG5vdGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm90ZSBvZiBub3Rlcykge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdmF1bHQuY2FjaGVkUmVhZChub3RlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXFtcXFxcWyR7a2V5d29yZH1cXFxcXVxcXFxdYCwgJ2cnKTtcclxuICAgICAgaWYgKGNvbnRlbnQubWF0Y2gocmVnZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBjaGVja2JveCBlbGVtZW50IGZvciBhIGJpLWxpbmsgb3B0aW9uLlxyXG4gICAqIEBwYXJhbSBrZXl3b3JkIC0gVGhlIGtleXdvcmQgZm9yIHRoZSBiaS1saW5rLlxyXG4gICAqIEBwYXJhbSBjaGVja2VkIC0gV2hldGhlciB0aGUgY2hlY2tib3ggaXMgc2VsZWN0ZWQuXHJcbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY2hlY2tib3ggZWxlbWVudC5cclxuICAgKi9cclxuICBjcmVhdGVDaGVja2JveChrZXl3b3JkOiBzdHJpbmcsIGNoZWNrZWQ6IGJvb2xlYW4pOiBIVE1MRWxlbWVudCB7XHJcbiAgICBjb25zdCBjaGVja2JveENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XHJcbiAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgIGNoZWNrYm94LmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgY2hlY2tib3hDb250YWluZXIuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xyXG5cclxuICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MubWFwKChiaUxpbmspID0+XHJcbiAgICAgICAgYmlMaW5rLmtleXdvcmQgPT09IGtleXdvcmRcclxuICAgICAgICAgID8geyAuLi5iaUxpbmssIGlzU2VsZWN0ZWQ6IGNoZWNrYm94LmNoZWNrZWQgfVxyXG4gICAgICAgICAgOiBiaUxpbmtcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNoZWNrYm94Q29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBkYXRlQmlMaW5rcygpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkQmlMaW5rcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MuZmlsdGVyKFxyXG4gICAgICAoYmlMaW5rKSA9PiBiaUxpbmsuaXNTZWxlY3RlZFxyXG4gICAgKTtcclxuICBcclxuICAgIGNvbnN0IHZhdWx0ID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0O1xyXG4gICAgY29uc3Qgbm90ZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XHJcbiAgICBjb25zdCB0b3RhbE5vdGVzID0gbm90ZXMubGVuZ3RoO1xyXG4gIFxyXG4gICAgbGV0IGluZGV4Q291bnQgPSAwO1xyXG4gICAgY29uc3Qga2V5d29yZFRvUmVnZXggPSBuZXcgTWFwKCk7XHJcbiAgXHJcbiAgICAvLyBDcmVhdGUgYSBtYXBwaW5nIG9mIHNlbGVjdGVkIGtleXdvcmRzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcmVnZXggcGF0dGVybnNcclxuICAgIGZvciAoY29uc3Qgc2VsZWN0ZWRCaUxpbmsgb2Ygc2VsZWN0ZWRCaUxpbmtzKSB7XHJcbiAgICAgIGNvbnN0IHsga2V5d29yZCB9ID0gc2VsZWN0ZWRCaUxpbms7XHJcbiAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IGBcXFxcYiR7a2V5d29yZC5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyl9XFxcXGJgO1xyXG4gICAgICBrZXl3b3JkVG9SZWdleC5zZXQoa2V5d29yZCwgbmV3IFJlZ0V4cChyZWdleFBhdHRlcm4sICdnJykpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0V4Y2x1ZGVkKG5vdGUucGF0aCkpIHtcclxuICAgICAgICBsZXQgY29udGVudCA9IGF3YWl0IHZhdWx0LnJlYWQobm90ZSk7XHJcbiAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gY29udGVudDtcclxuICAgIFxyXG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0ZWRCaUxpbmsgb2Ygc2VsZWN0ZWRCaUxpbmtzKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGtleXdvcmQgfSA9IHNlbGVjdGVkQmlMaW5rO1xyXG4gICAgICAgICAgY29uc3QgcmVnZXggPSBrZXl3b3JkVG9SZWdleC5nZXQoa2V5d29yZCk7XHJcbiAgICAgICAgICBpZiAocmVnZXgpIHtcclxuICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSB1cGRhdGVkQ29udGVudC5yZXBsYWNlKHJlZ2V4LCBgW1ske2tleXdvcmR9XV1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBpZiAodXBkYXRlZENvbnRlbnQgIT09IGNvbnRlbnQpIHtcclxuICAgICAgICAgIGF3YWl0IHZhdWx0Lm1vZGlmeShub3RlLCB1cGRhdGVkQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaW5kZXhDb3VudCsrO1xyXG4gICAgICAgIHRoaXMuc2hvd1Byb2dyZXNzKGluZGV4Q291bnQsIHRvdGFsTm90ZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICBcclxuICAgIC8vIFVwZGF0ZSB0aGUgaXNTZWxlY3RlZCBzdGF0dXMgZm9yIHNlbGVjdGVkIGJpLWxpbmtzXHJcbiAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rcy5tYXAoKGJpTGluaykgPT5cclxuICAgICAgc2VsZWN0ZWRCaUxpbmtzLnNvbWUoKHsga2V5d29yZCB9KSA9PiBiaUxpbmsua2V5d29yZCA9PT0ga2V5d29yZClcclxuICAgICAgICA/IHsgLi4uYmlMaW5rLCBpc1NlbGVjdGVkOiBmYWxzZSB9XHJcbiAgICAgICAgOiBiaUxpbmtcclxuICAgICk7XHJcbiAgXHJcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICBcclxuICAgIG5ldyBOb3RpY2UoJ1VwZGF0ZSBmaW5pc2hlZCEnKTtcclxuICB9XHJcbiAgXHJcbiAgXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub3RlIHBhdGggaXMgZXhjbHVkZWQuXHJcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgbm90ZS5cclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub3RlIHBhdGggaXMgZXhjbHVkZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBpc0V4Y2x1ZGVkKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3RlcyA9PT0gJycpIHJldHVybiBmYWxzZTtcclxuICBcclxuICAgIHJldHVybiBwYXRoLmluY2x1ZGVzKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF0aXZlUGF0aE9mRXhjbHVkZWROb3Rlcy50b1N0cmluZygpKTtcclxuICB9XHJcbiAgXHJcblxyXG4gIC8qKlxyXG4gICAqIElnbm9yZSB0aGUgc2VsZWN0ZWQgYmktbGluayBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGFzeW5jIGlnbm9yZVNlbGVjdGVkT3B0aW9ucygpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MuZmlsdGVyKFxyXG4gICAgICAoYmlMaW5rKSA9PiBiaUxpbmsuaXNTZWxlY3RlZFxyXG4gICAgKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkT3B0aW9uIG9mIHNlbGVjdGVkT3B0aW9ucykge1xyXG4gICAgICBjb25zdCB7IGtleXdvcmQgfSA9IHNlbGVjdGVkT3B0aW9uO1xyXG4gICAgICAvLyBzZXQgdGhlIGlzU2VsZWN0ZWQgc3RhdHVzIHRvIGZhbHNlXHJcbiAgICAgIHNlbGVjdGVkT3B0aW9uLmlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIGFkZCBzZWxlY3RlZCBvcHRpb25zIHRvIGlnbm9yZWQgbGlzdFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnNvbWUoXHJcbiAgICAgICAgICAoaWdub3JlZENvbnRlbnQpID0+IGlnbm9yZWRDb250ZW50LmtleXdvcmQgPT09IGtleXdvcmRcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnB1c2goc2VsZWN0ZWRPcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBzZWxlY3RlZCBvcHRpb25zIGZyb20gdGhlIGJpLWxpbmtzIGFycmF5XHJcbiAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmlMaW5rcy5maWx0ZXIoXHJcbiAgICAgIChiaUxpbmspID0+ICFiaUxpbmsuaXNTZWxlY3RlZFxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zZWFyY2hQb3NzaWJsZUJpTGlua3MoKTtcclxuICAgIGF3YWl0IHRoaXMuZGlzcGxheSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGxheSB0aGUgaWdub3JlZCBjb250ZW50IGxpc3QuXHJcbiAgICovXHJcbiAgYXN5bmMgZGlzcGxheUlnbm9yZWRDb250ZW50TGlzdCgpIHtcclxuICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29uc3QgaWdub3JlZENvbnRlbnRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKCdJZ25vcmVkIGNvbnRlbnQgbGlzdCcpXHJcbiAgICAgIC5zZXREZXNjKCdLZXl3b3JkcyB0aGF0IHlvdSB3YW50IHRvIGlnbm9yZScpO1xyXG5cclxuICAgIGNvbnN0IGlnbm9yZWRDb250ZW50VGFibGUgPSBjb250YWluZXJFbC5jcmVhdGVFbCgndGFibGUnLCB7XHJcbiAgICAgIGNsczogJ2NvbnRlbnQtbGlua2VyLWlnbm9yZWQtY29udGVudC10YWJsZScsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpZ25vcmVkQ29udGVudFRoZWFkID0gaWdub3JlZENvbnRlbnRUYWJsZS5jcmVhdGVUSGVhZCgpO1xyXG4gICAgY29uc3QgaWdub3JlZENvbnRlbnRIZWFkZXJSb3cgPSBpZ25vcmVkQ29udGVudFRoZWFkLmluc2VydFJvdygpO1xyXG4gICAgaWdub3JlZENvbnRlbnRIZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ05vLic7XHJcbiAgICBpZ25vcmVkQ29udGVudEhlYWRlclJvdy5pbnNlcnRDZWxsKCkudGV4dENvbnRlbnQgPSAnQ291bnQnO1xyXG4gICAgaWdub3JlZENvbnRlbnRIZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ0tleXdvcmQnO1xyXG4gICAgaWdub3JlZENvbnRlbnRIZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ1NlbGVjdGVkJztcclxuXHJcbiAgICBjb25zdCBzb3J0ZWRJZ25vcmVkTGlzdCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBpZ25vcmVkQ29udGVudFRib2R5ID0gaWdub3JlZENvbnRlbnRUYWJsZS5jcmVhdGVUQm9keSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRJZ25vcmVkTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB7IGtleXdvcmQsIGNvdW50LCBpc1NlbGVjdGVkIH0gPSBzb3J0ZWRJZ25vcmVkTGlzdFtpXTtcclxuXHJcbiAgICAgIGNvbnN0IHJvdyA9IGlnbm9yZWRDb250ZW50VGJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgIHJvdy5pbnNlcnRDZWxsKDApLnRleHRDb250ZW50ID0gKGkgKyAxKS50b1N0cmluZygpO1xyXG4gICAgICByb3cuaW5zZXJ0Q2VsbCgxKS50ZXh0Q29udGVudCA9IGNvdW50ID8gY291bnQudG9TdHJpbmcoKSA6ICcnO1xyXG4gICAgICByb3cuaW5zZXJ0Q2VsbCgyKS50ZXh0Q29udGVudCA9IGtleXdvcmQ7XHJcbiAgICAgIHJvdy5pbnNlcnRDZWxsKDMpLmFwcGVuZENoaWxkKFxyXG4gICAgICAgIHRoaXMuY3JlYXRlSWdub3JlZENoZWNrYm94KGtleXdvcmQsIGlzU2VsZWN0ZWQpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoaWdub3JlZENvbnRlbnRUYWJsZSk7XHJcblxyXG4gICAgY29uc3QgcmVtb3ZlQnV0dG9uID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuICAgICAgdGV4dDogJ1JlbW92ZSBzZWxlY3RlZCBvcHRpb24ocykgZnJvbSBpZ25vcmVkIGNvbnRlbnQgbGlzdCcsXHJcbiAgICB9KTtcclxuICAgIHJlbW92ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gUmVtb3ZlIHRoZSBzZWxlY3RlZCBvcHRpb25zIGZyb20gdGhlIGlnbm9yZWQgY29udGVudCBsaXN0XHJcbiAgICAgIHRoaXMucmVtb3ZlRnJvbUlnbm9yZWRMaXN0KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGNoZWNrYm94IGVsZW1lbnQgZm9yIGFuIGlnbm9yZWQgb3B0aW9uLlxyXG4gICAqIEBwYXJhbSBrZXl3b3JkIC0gVGhlIGtleXdvcmQgZm9yIHRoZSBpZ25vcmVkIG9wdGlvbi5cclxuICAgKiBAcGFyYW0gY2hlY2tlZCAtIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIHNlbGVjdGVkLlxyXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGNoZWNrYm94IGVsZW1lbnQuXHJcbiAgICovXHJcbiAgY3JlYXRlSWdub3JlZENoZWNrYm94KGtleXdvcmQ6IHN0cmluZywgY2hlY2tlZDogYm9vbGVhbik6IEhUTUxFbGVtZW50IHtcclxuICAgIGNvbnN0IGNoZWNrYm94Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcclxuICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gICAgY2hlY2tib3guY2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgICBjaGVja2JveENvbnRhaW5lci5hcHBlbmRDaGlsZChjaGVja2JveCk7XHJcblxyXG4gICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50Lm1hcChcclxuICAgICAgICAoaWdub3JlZENvbnRlbnQpID0+XHJcbiAgICAgICAgICBpZ25vcmVkQ29udGVudC5rZXl3b3JkID09PSBrZXl3b3JkXHJcbiAgICAgICAgICAgID8geyAuLi5pZ25vcmVkQ29udGVudCwgaXNTZWxlY3RlZDogY2hlY2tib3guY2hlY2tlZCB9XHJcbiAgICAgICAgICAgIDogaWdub3JlZENvbnRlbnRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNoZWNrYm94Q29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBzZWxlY3RlZCBvcHRpb25zIGZyb20gdGhlIGlnbm9yZWQgY29udGVudCBsaXN0LlxyXG4gICAqL1xyXG4gIGFzeW5jIHJlbW92ZUZyb21JZ25vcmVkTGlzdCgpIHtcclxuICAgIC8vIEdldCBzZWxlY3RlZCBpZ25vcmVkIG9wdGlvbnNcclxuICAgIGNvbnN0IHNlbGVjdGVkSWdub3JlZE9wdGlvbnMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pZ25vcmVkQ29udGVudC5maWx0ZXIoXHJcbiAgICAgIChpZ25vcmVkQ29udGVudCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBpZ25vcmVkQ29udGVudC5pc1NlbGVjdGVkO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIGZvciAoY29uc3Qgc2VsZWN0ZWRJZ25vcmVkT3B0aW9uIG9mIHNlbGVjdGVkSWdub3JlZE9wdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyBrZXl3b3JkIH0gPSBzZWxlY3RlZElnbm9yZWRPcHRpb247XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZnJvbSBpZ25vcmVkIGNvbnRlbnQgbGlzdFxyXG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LmZpbmRJbmRleChcclxuICAgICAgICAoaWdub3JlZENvbnRlbnQpID0+IGlnbm9yZWRDb250ZW50LmtleXdvcmQgPT09IGtleXdvcmRcclxuICAgICAgKTtcclxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZWRDb250ZW50LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTsgLy8gUmVmcmVzaCB0aGUgaWdub3JlZCBjb250ZW50IGxpc3RcclxuICB9XHJcblxyXG4gIGFzeW5jIHNob3dQcm9ncmVzcyhpbmRleENvdW50OiBudW1iZXIsIHRvdGFsTnVtYmVyOiBudW1iZXIpXHJcbiAge1xyXG4gICAgICBpZiAoaW5kZXhDb3VudCA9PSAxIHx8IFxyXG4gICAgICAgIGluZGV4Q291bnQgJSBNYXRoLmZsb29yKHRvdGFsTnVtYmVyLzEwKSAgPT0gMCB8fCBcclxuICAgICAgICBpbmRleENvdW50ID09IHRvdGFsTnVtYmVyKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVXBkYXRpbmc6ICR7aW5kZXhDb3VudH0gb2YgJHt0b3RhbE51bWJlcn1gO1xyXG4gICAgICBuZXcgTm90aWNlKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGlzcGxheUJpRGlyZWN0aW9uYWxMaW5rc0xpc3QoKSB7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG4gIFxyXG4gICAgY29uc3QgbGlua2VkQ29udGVudFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoJ0xpbmtlZCBjb250ZW50IGxpc3QnKVxyXG4gICAgICAuc2V0RGVzYygnQ29udGVudCB0aGF0IGlzIGFscmVhZHkgYmktZGlyZWN0aW9uYWwtbGlua2VkLiBDb3VudCBpbmNsdWRpbmcgbm9uLWJpLWRpcmVjdGlvbmFsLWxpbmtlZCBmb3JtYXQnKTtcclxuICBcclxuICAgIGNvbnN0IGxpbmtlZENvbnRlbnRUYWJsZSA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCd0YWJsZScsIHtcclxuICAgICAgY2xzOiAnY29udGVudC1saW5rZXItbGlua2VkLWNvbnRlbnQtdGFibGUnLFxyXG4gICAgfSk7XHJcbiAgXHJcbiAgICBjb25zdCB0aGVhZCA9IGxpbmtlZENvbnRlbnRUYWJsZS5jcmVhdGVUSGVhZCgpO1xyXG4gICAgY29uc3QgaGVhZGVyUm93ID0gdGhlYWQuaW5zZXJ0Um93KCk7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ05vLic7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ0NvdW50JztcclxuICAgIGhlYWRlclJvdy5pbnNlcnRDZWxsKCkudGV4dENvbnRlbnQgPSAnS2V5d29yZCc7XHJcbiAgICBoZWFkZXJSb3cuaW5zZXJ0Q2VsbCgpLnRleHRDb250ZW50ID0gJ1NlbGVjdGVkJztcclxuICBcclxuICAgIC8vIFNvcnQgdGhlIGJpLWxpbmtzIGJ5IGNvdW50IGluIGRlc2NlbmRpbmcgb3JkZXJcclxuICAgIGNvbnN0IHNvcnRlZEJpTGlua3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudCk7XHJcbiAgXHJcbiAgICBjb25zdCB0Ym9keSA9IGxpbmtlZENvbnRlbnRUYWJsZS5jcmVhdGVUQm9keSgpO1xyXG4gICAgY29uc3QgYmF0Y2hTaXplID0gMTAwOyAvLyBBZGp1c3QgdGhlIGJhdGNoIHNpemUgYXMgbmVlZGVkXHJcbiAgICBsZXQgaW5kZXhDb3VudCA9IDA7XHJcbiAgICBcclxuICAgIGNvbnN0IHByb2Nlc3NCYXRjaCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaFNpemUgJiYgaW5kZXhDb3VudCA8IHNvcnRlZEJpTGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGNvdW50LCBpc1NlbGVjdGVkIH0gPSBzb3J0ZWRCaUxpbmtzW2luZGV4Q291bnRdO1xyXG4gIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXl3b3JkIGlzIGFscmVhZHkgYSBiaS1saW5rIGluIGFueSBub3RlXHJcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5QmlMaW5rID0gYXdhaXQgdGhpcy5pc0FscmVhZHlCaUxpbmsoa2V5d29yZCk7XHJcbiAgXHJcbiAgICAgICAgaWYgKGlzQWxyZWFkeUJpTGluayAmJiAhdGhpcy5pc0lnbm9yZWQoa2V5d29yZCkpIHtcclxuICAgICAgICAgIGNvbnN0IHJvdyA9IHRib2R5Lmluc2VydFJvdygpO1xyXG4gICAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IChpbmRleENvdW50ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgIHJvdy5pbnNlcnRDZWxsKCkudGV4dENvbnRlbnQgPSBjb3VudC50b1N0cmluZygpO1xyXG4gICAgICAgICAgcm93Lmluc2VydENlbGwoKS50ZXh0Q29udGVudCA9IGtleXdvcmQ7XHJcbiAgICAgICAgICByb3cuaW5zZXJ0Q2VsbCgpLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlQ2hlY2tib3goa2V5d29yZCwgaXNTZWxlY3RlZCkpO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBpbmRleENvdW50Kys7XHJcbiAgICAgICAgdGhpcy5zaG93UHJvZ3Jlc3MoaW5kZXhDb3VudCwgc29ydGVkQmlMaW5rcy5sZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIHByb2Nlc3MsIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgYmF0Y2hcclxuICAgICAgaWYgKGluZGV4Q291bnQgPCBzb3J0ZWRCaUxpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgIHNldFRpbWVvdXQocHJvY2Vzc0JhdGNoLCAwKTsgLy8gVXNlIHNldFRpbWVvdXQgdG8geWllbGQgdG8gdGhlIGV2ZW50IGxvb3BcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgbm93IHVwZGF0ZSB0aGUgVUlcclxuICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZChsaW5rZWRDb250ZW50VGFibGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlbW92ZUJ1dHRvbiA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcbiAgICAgICAgICB0ZXh0OiAnUmVtb3ZlIGJpLWRpcmVjdGlvbmFsIGxpbmtzIGZvciBzZWxlY3RlZCBvcHRpb24ocyknLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlbW92ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIC8vIFJlbW92ZSBiaS1kaXJlY3Rpb25hbCBsaW5rcyBmb3Igc2VsZWN0ZWQgb3B0aW9ucyBmcm9tIHRoZSBsaW5rZWQgY29udGVudCBsaXN0XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZVNlbGVjdGVkQmlMaW5rcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIFxyXG4gICAgLy8gU3RhcnQgcHJvY2Vzc2luZyB0aGUgZmlyc3QgYmF0Y2hcclxuICAgIHByb2Nlc3NCYXRjaCgpO1xyXG4gIH1cclxuICBcclxuICBhc3luYyByZW1vdmVTZWxlY3RlZEJpTGlua3MoKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZEJpTGlua3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzLmZpbHRlcihcclxuICAgICAgKGJpTGluaykgPT4gYmlMaW5rLmlzU2VsZWN0ZWRcclxuICAgICk7XHJcbiAgXHJcbiAgICAvLyBTdGVwIDE6IENyZWF0ZSBhIHNldCBvZiBzZWxlY3RlZCBrZXl3b3Jkc1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRLZXl3b3JkcyA9IG5ldyBTZXQ8c3RyaW5nPihcclxuICAgICAgc2VsZWN0ZWRCaUxpbmtzLm1hcCgoYmlMaW5rKSA9PiBiaUxpbmsua2V5d29yZClcclxuICAgICk7XHJcbiAgXHJcbiAgICBjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xyXG4gICAgY29uc3Qgbm90ZXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxhdGl2ZVBhdGhPZkV4Y2x1ZGVkTm90ZXMgPT09ICcnXHJcbiAgICAgID8gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXHJcbiAgICAgIDogdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZpbHRlcihmaWxlID0+ICFmaWxlLnBhdGguaW5jbHVkZXModGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXRpdmVQYXRoT2ZFeGNsdWRlZE5vdGVzLnRvU3RyaW5nKCkpKTtcclxuICBcclxuICAgIGxldCBpbmRleENvdW50ID0gMDtcclxuICBcclxuICAgIC8vIFN0ZXAgMjogSXRlcmF0ZSB0aHJvdWdoIGFsbCBub3RlcyBpbiB0aGUgbGlicmFyeVxyXG4gICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XHJcbiAgICAgIGxldCBjb250ZW50ID0gYXdhaXQgdmF1bHQucmVhZChub3RlKTtcclxuICAgICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XHJcbiAgXHJcbiAgICAgIC8vIFN0ZXAgMzogQ2hlY2sgaWYgdGhlIG5vdGUgY29udGFpbnMgYW55IG9mIHRoZSBzZWxlY3RlZCBrZXl3b3Jkc1xyXG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGVkS2V5d29yZCBvZiBzZWxlY3RlZEtleXdvcmRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgYFxcXFxbXFxcXFske3NlbGVjdGVkS2V5d29yZH1cXFxcXVxcXFxdYCxcclxuICAgICAgICAgICdnJ1xyXG4gICAgICAgICk7XHJcbiAgXHJcbiAgICAgICAgaWYgKGNvbnRlbnQubWF0Y2gocmVnZXgpKSB7XHJcbiAgICAgICAgICAvLyBTdGVwIDQ6IFJlbW92ZSB0aGUgYmlkaXJlY3Rpb25hbCBsaW5rXHJcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHJlZ2V4LCBzZWxlY3RlZEtleXdvcmQpO1xyXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvLyBTdGVwIDU6IFVwZGF0ZSB0aGUgbm90ZSBpZiBpdCB3YXMgbW9kaWZpZWRcclxuICAgICAgaWYgKG1vZGlmaWVkKSB7XHJcbiAgICAgICAgYXdhaXQgdmF1bHQubW9kaWZ5KG5vdGUsIGNvbnRlbnQpO1xyXG4gICAgICAgIGluZGV4Q291bnQrKztcclxuICAgICAgICB0aGlzLnNob3dQcm9ncmVzcyhpbmRleENvdW50LCBub3Rlcy5sZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBSZW1vdmUgdGhlIHNlbGVjdGVkIG9wdGlvbnMgZnJvbSB0aGUgYmktbGlua3MgYXJyYXlcclxuICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmJpTGlua3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iaUxpbmtzLmZpbHRlcihcclxuICAgICAgKGJpTGluaykgPT4gIWJpTGluay5pc1NlbGVjdGVkXHJcbiAgICApO1xyXG4gIFxyXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICBuZXcgTm90aWNlKCdTZWxlY3RlZCBiaS1kaXJlY3Rpb25hbCBsaW5rcyByZW1vdmVkIScpO1xyXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uc2VhcmNoUG9zc2libGVCaUxpbmtzKCk7XHJcbiAgICBhd2FpdCB0aGlzLmRpc3BsYXkoKTtcclxuICB9ICBcclxufVxyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQStEO0FBcUIvRCxJQUFxQixzQkFBckIsY0FBaUQsdUJBQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU90RCxNQUFNLFNBQVM7QUFDYixVQUFNLEtBQUssYUFBYTtBQUV4QixZQUFRLElBQUksK0JBQStCO0FBRTNDLFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3BCLGNBQU0sS0FBSyxzQkFBc0I7QUFDakMsY0FBTSxLQUFLLGFBQWE7QUFBQSxNQUMxQjtBQUFBLElBQ0YsQ0FBQztBQUVELFNBQUssY0FBYyxJQUFJLHdCQUF3QixLQUFLLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU0sZUFBZTtBQUNuQixTQUFLLFdBQVcsT0FBTztBQUFBLE1BQ3JCLENBQUM7QUFBQSxNQUNEO0FBQUEsUUFDRSxTQUFTLENBQUM7QUFBQSxRQUNWLGNBQWM7QUFBQSxRQUNkLGdCQUFnQixDQUFDO0FBQUEsUUFDakIsNkJBQTZCO0FBQUEsTUFDL0I7QUFBQSxNQUNBLE1BQU0sS0FBSyxTQUFTO0FBQUEsSUFDdEI7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLGVBQWU7QUFDbkIsU0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQzdCO0FBQUE7QUFB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
